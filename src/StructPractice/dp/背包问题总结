问题1：
描述：在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i],你不可以将物品进行切割。

输入：
    数组 = [3,4,8,5]
    backpack size = 10
输出：
    9

题解：动态规划，维护二维数组
    动态规划：一个大的问题可以划分为很多子问题，子问题间有联系，往往后面的解建立在前面的解知道的情况下。
    分治：分治，把大的问题划分为几个子问题，往往相互独立，比如说汉诺塔的问题。

    步骤：
        1:建立二维数组dps[i][j]，大小为（n+1,m+1), i 为物品的下标，j为背包的重量，表示在物品 0-i 出现时，背包容量 j 对应的最大的容量。
        2:初始化第一行和第一列为0，表示空间为0的背包，只能装0体积的物品，作为计算的边界；
        3:开始迭代，当第 i 个物品出现时，放入体积为 j 的背包，则：
            当 j < A[i-1]  即物品的重量大于背包的重量，此时  dps[i][j] = dps[i-1][j] ,因为新的物品不能装到此时的背包 j 里面，所以最大的容量任然是上一次的最大值;
            当 j >= A[i-1]   即物品的重量小于背包的重量，此时考虑是否要更新背包里面的物品，更新的条件为dps[i][j] =  Math.max(A[i-1]+dps[i-1][j-A[i-1]],dps[i-1][j])
                             意思是，比较   此时物品的重量 + （背包容量-物品体积）的容量对应的背包在上一个物品的时候所能容纳的最大的物品重量  ？  背包容量 j 在上一个物品时的最大容纳的重量
    开始计算
    0 1 2 3 4 5 6 7 8 9 10
  0 0 0 0 0 0 0 0 0 0 0 0
  3 0 0 0 0 0 0 0 0 0 0 0
  4 0 0 0 0 0 0 0 0 0 0 0
  5 0 0 0 0 0 0 0 0 0 0 0
  8 0 0 0 0 0 0 0 0 0 0 0
    开始计算
    0 0 0 0 0 0 0 0 0 0 0
    0 0 0 3 3 3 3 3 3 3 3
    0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0
    开始计算
    0 0 0 0 0 0 0 0 0 0 0
    0 0 0 3 3 3 3 3 3 3 3
    0 0 0 3 4 4 4 7 7 7 7
    0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0
    开始计算
    0 0 0 0 0 0 0 0 0 0 0
    0 0 0 3 3 3 3 3 3 3 3
    0 0 0 3 4 4 4 7 7 7 7
    0 0 0 3 4 4 4 7 8 8 8
    0 0 0 0 0 0 0 0 0 0 0
    开始计算
    0 0 0 0 0 0 0 0 0 0 0
    0 0 0 3 3 3 3 3 3 3 3
    0 0 0 3 4 4 4 7 7 7 7
    0 0 0 3 4 4 4 7 8 8 8
    0 0 0 3 4 5 5 7 8 9 9
    9



问题2：

描述：有 n 个物品和一个大小为 m 的背包. 给定数组 A 表示每个物品的大小和数组 V 表示每个物品的价值.
问最多能装入背包的总价值是多大?

    A[i], V[i], n, m 均为整数
    你不能将物品进行切分
    你所挑选的要装入背包的物品的总大小不能超过 m
    每个物品只能取一次
    m <= 1000m<=1000\
    len(A),len(V)<=100len(A),len(V)<=100


样例
    输入：
        m = 10
        A = [2, 3, 5, 7]
        V = [1, 5, 2, 4]
    输出：
        9

    题解：动态规划，维护二维数组
        动态规划：一个大的问题可以划分为很多子问题，子问题间有联系，往往后面的解建立在前面的解知道的情况下。

        步骤：
            1:建立二维数组dps[i][j]，大小为（n+1,m+1), i 为物品的下标，j为背包的重量，表示在物品 0-i 出现时，背包容量 j 对应的最大的价值。
            2:初始化第一行和第一列为0，表示空间为0的背包，只能装0价值的物品，作为计算的边界；
            3:开始迭代，当第 i 个物品出现时，放入体积为 j 的背包，则：
                当 j < A[i-1]  即物品的重量大于背包的重量，此时  dps[i][j] = dps[i-1][j] ,因为新的物品不能装到此时的背包 j 里面，所以最大的价值任然是上一次的最大值;
                当 j >= A[i-1]   即物品的重量小于背包的重量，此时考虑是否要更新背包里面的物品，更新的条件为dps[i][j] =  Math.max(V[i-1]+dps[i-1][j-A[i-1]],dps[i-1][j])
                                 意思是，比较   此时物品的价格 + （背包容量-物品体积）的容量对应的背包在上一个物品的时候所能容纳的最大的物品价值  ？  背包容量 j 在上一个物品时的最大容纳的价值

        开始计算
        0 1 2 3 4 5 6 7 8 9 10
    0 0 0 0 0 0 0 0 0 0 0 0 0
    1 2 0 0 0 0 0 0 0 0 0 0 0
    5 3 0 0 0 0 0 0 0 0 0 0 0
    2 5 0 0 0 0 0 0 0 0 0 0 0
    4 7 0 0 0 0 0 0 0 0 0 0 0
        开始计算
        0 0 0 0 0 0 0 0 0 0 0
        0 0 1 1 1 1 1 1 1 1 1
        0 0 0 0 0 0 0 0 0 0 0
        0 0 0 0 0 0 0 0 0 0 0
        0 0 0 0 0 0 0 0 0 0 0
        开始计算
        0 0 0 0 0 0 0 0 0 0 0
        0 0 1 1 1 1 1 1 1 1 1
        0 0 1 5 5 6 6 6 6 6 6
        0 0 0 0 0 0 0 0 0 0 0
        0 0 0 0 0 0 0 0 0 0 0
        开始计算
        0 0 0 0 0 0 0 0 0 0 0
        0 0 1 1 1 1 1 1 1 1 1
        0 0 1 5 5 6 6 6 6 6 6
        0 0 1 5 5 6 6 6 7 7 8
        0 0 0 0 0 0 0 0 0 0 0
        开始计算
        0 0 0 0 0 0 0 0 0 0 0
        0 0 1 1 1 1 1 1 1 1 1
        0 0 1 5 5 6 6 6 6 6 6
        0 0 1 5 5 6 6 6 7 7 8
        0 0 1 5 5 6 6 6 7 7 9
        9


问题三：
描述：给定 n 种物品, 每种物品都有无限个. 第 i 个物品的体积为 A[i], 价值为 V[i].
再给定一个容量为 m 的背包. 问可以装入背包的最大价值是多少?

    不能将一个物品分成小块.
    放入背包的物品的总大小不能超过 m.
样例

输入: A = [2, 3, 5, 7], V = [1, 5, 2, 4], m = 10
输出: 15
解释: 装入三个物品 1 (A[1] = 3, V[1] = 5), 总价值 15.


  题解： 动态规划，维护二维数组
        动态规划：一个大的问题可以划分为很多子问题，子问题间有联系，往往后面的解建立在前面的解知道的情况下。

        步骤：
            1:建立二维数组dps[i][j]，大小为（n+1,m+1), i 为物品的下标，j为背包的重量，表示在物品 0-i 出现时，背包容量 j 对应的最大的价值。
            2:初始化第一行和第一列为0，表示空间为0的背包，只能装0价值的物品，作为计算的边界；
            3:开始迭代，当第 i 个物品出现时，放入体积为 j 的背包，则：
                当 j < A[i-1]  即物品的重量大于背包的重量，此时  dps[i][j] = dps[i-1][j] ,因为新的物品不能装到此时的背包 j 里面，所以最大的价值任然是上一次的最大值;
                当 j >= A[i-1]   即物品的重量小于背包的重量，此时考虑是否要更新背包里面的物品，更新的条件为dps[i][j] =  Math.max(V[i-1]+MAth.max(dps[i-1][j-A[i-1]],dps[i][j-A[i-1]]),dps[i-1][j])
                                 意思是，先比较装入了此时的物品背包剩下的空间，装这次的物品还是装上次的物品时该容量对应的最大价值MAth.max(dps[i-1][j-A[i-1]],dps[i][j-A[i-1]])
                                 然后比较   此时物品的价格 + （背包容量-物品体积）的容量对应的背包容纳的最大的物品价值  ？  背包容量 j 在上一个物品时的最大容纳的价值

  开始计算
  0 0 0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0 0 0
  开始计算
  0 0 0 0 0 0 0 0 0 0 0
  0 0 1 1 2 2 3 3 4 4 5
  0 0 0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0 0 0
  开始计算
  0 0 0 0 0 0 0 0 0 0 0
  0 0 1 1 2 2 3 3 4 4 5
  0 0 1 5 5 6 10 10 11 15 15
  0 0 0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0 0 0
  开始计算
  0 0 0 0 0 0 0 0 0 0 0
  0 0 1 1 2 2 3 3 4 4 5
  0 0 1 5 5 6 10 10 11 15 15
  0 0 1 5 5 6 10 10 11 15 15
  0 0 0 0 0 0 0 0 0 0 0
  开始计算
  0 0 0 0 0 0 0 0 0 0 0
  0 0 1 1 2 2 3 3 4 4 5
  0 0 1 5 5 6 10 10 11 15 15
  0 0 1 5 5 6 10 10 11 15 15
  0 0 1 5 5 6 10 10 11 15 15
  15
